var swag=swag||{};{class j{constructor(a,b){this.layers=a||[],this.batchSize=19,this.epoch=0,this.lr=.01,this.optimizer=b||"SGD",this.connectLayers()}set learningRate(b){for(var a=0;a<this.layers.length;a++)this.layers[a].lr=b;this.lr=b}get learningRate(){return this.lr}connectLayers(){for(var a=0;a<this.layers.length;a++){if(a<this.layers.length-1){if(this.layers[a].outSize()!=this.layers[a+1].inSize())throw`Failure connecting ${this.layers[a].constructor.name} layer with ${this.layers[a+1].constructor.name},${this.layers[a].constructor.name} output size: ${this.layers[a].outSize()}${this.layers[a].outSizeDimensions?" ("+this.layers[a].outSizeDimensions()+")":""}, ${this.layers[a+1].constructor.name} input size: ${this.layers[a+1].inSize()}${this.layers[a+1].outSizeDimensions?" ("+this.layers[a+1].outSizeDimensions()+")":""}`;this.layers[a+1].inData=this.layers[a].outData,this.layers[a].nextLayer=this.layers[a+1]}0!=a&&(this.layers[a].previousLayer=this.layers[a-1])}}forward(a){if(!Array.isArray(a)){if("number"==typeof a)a=[a];else throw"INPUT ARRAYS INTO FORWARDS FUNCTION ONLY!"}this.layers[0].forward(a);for(var b=1;b<this.layers.length;b++)this.layers[b].forward();return new Float32Array(this.layers[this.layers.length-1].outData)}enableGPU(){for(var a=0;a<this.layers.length;a++)this.layers[a].gpuEnabled=!0,this.layers[a].initGPU&&this.layers[a].initGPU()}mutate(b,c){for(var a=0;a<this.layers.length;a++)this.layers[a].mutate&&this.layers[a].mutate(b,c)}disableGPU(){for(var a=0;a<this.layers.length;a++)this.layers[a].gpuEnabled=!1}save(f,g){if(f){if(swag.isBrowser()){var d=document.createElement("a"),h=new Blob([this.save()]);d.href=URL.createObjectURL(h),d.download="model.json",d.click()}else require("fs").writeFileSync(g,this.save())}let a={};a.layerAmount=this.layers.length,a.optimizer=this.optimizer,a.lr=this.lr,a.batchSize=this.batchSize;for(var b=0;b<this.layers.length;b++){let c=this.layers[b],e={};if(e.type=c.constructor.name,a["layer"+b]=e,!c.save)throw`Layer ${b} (${c.constructor.name}) in your network doesnt have a save() function so your model cant be saved`;e.layerData=c.save()}return JSON.stringify(a)}static load(e){let a=JSON.parse(e),d=[];for(var b=0;b<a.layerAmount;b++){let f=swag[a["layer"+b].type].load(a["layer"+b].layerData);d.push(f)}let c=new swag.Net(d,a.optimizer);return c.learningRate=a.lr,c.batchSize=a.batchSize,c}copy(a){}train(b,c){this.forward(b);let d=this.layers[this.layers.length-1].backward(c);for(var a=this.layers.length-2;a>=0;a--)this.layers[a].backward();if(this.epoch++,this.epoch%this.batchSize==0)for(var a=this.layers.length-1;a>=0;a--)this.layers[a].updateParams&&this.layers[a].updateParams(this.optimizer);return d}}swag.Net=j}var swag=swag||{};{class k{constructor(e,c,f,g,h){this.networks=[],this.popSize=c,this.highScore=0,this.mutationRate=g||.3,this.mutationIntensity=h||.6,this.elitism=f;let a=new swag.Net(e);a.score=0;for(let d=0;d<c-1;d++){let b=new swag.Net;b.copy(a),b.score=0,this.networks.push(b)}this.networks.push(a)}cullAndBreed(){this.networks.sort((a,b)=>a.score>b.score?-1:1),this.highScore=this.networks[0].score<this.highScore?this.highScore:this.networks[0].score;let d=[];for(let b=0;b<this.elitism;b++)this.networks[b].score=0,d.push(this.networks[b]);for(let e=0;e<this.popSize-this.elitism;e++)for(let a=0;a<this.popSize;a++){if(.3>Math.random()){let c=new swag.Net;c.score=0,c.copy(this.networks[e]),c.mutate(.6,this.mutationRate),d.push(c),a=this.popSize+5}a==this.popSize-1&&(a=0)}this.networks=d}}swag.Population=k}var swag=swag||{};{var t=!1,u=0,l=function(){if(t)return t=!1,u;var b=2*Math.random()-1,c=2*Math.random()-1,a=b*b+c*c;if(0==a||a>1)return l();var d=Math.sqrt(-2*Math.log(a)/a);return u=c*d,t=!0,b*d},m=()=>"undefined"!=typeof window;let n=function(a,b,c){return Math.max(Math.min(a,c|=1),b|=0)},o=function(a){return a},p=function(a,b){if(Math.abs(a)>(b|=3)){var c=b*a/Math.abs(a);return p(a=c-(a-c),b)}return a},q=function(b,d){for(var c=0,a=0;a<b.length;a++)c+=Math.pow(b[a]-d[a],2);return c/b.length},r=function(f,d,i,j,a){let g=1;for(var c=0;c<f.layers.length;c++)"ConvLayer"!=f.layers[c].constructor.name&&"MaxPoolLayer"!=f.layers[c].constructor.name&&(f.layers[c].inSize()>g&&(g=f.layers[c].inSize()),f.layers[c].outSize()>g&&(g=f.layers[c].outSize())),d.fillStyle="grey",d.fillRect(i,j,5+f.layers.length*a*10+a,5+g*a*2);for(c=0;c<f.layers.length;c++){let b=f.layers[c];if("ConvLayer"!=b.constructor.name&&"MaxPoolLayer"!=b.constructor.name){for(var h=0;h<b.outSize();h++)d.fillStyle="rgb("+255*b.outData[e]+","+255*b.outData[e]+","+255*b.outData[e]+")",d.fillRect(i+5+(c+1)*a*10,j+5+h*a*2+(g*a*2/2-b.outSize()*a*2/2),a,a);for(var e=0;e<b.inSize();e++)d.fillStyle="rgb("+255*b.inData[e]+","+255*b.inData[e]+","+255*b.inData[e]+")",d.fillRect(i+5+c*a*10,j+5+e*a*2+(g*a*2/2-b.inSize()*a*2/2),a,a)}if("FCLayer"==b.constructor.name)for(var e=0;e<b.inSize();e++)for(var h=0;h<b.outSize();h++)d.strokeStyle="rgb("+ -(255*b.w[e*b.outSize()+h])+","+255*b.w[e*b.outSize()+h]+",0)",d.beginPath(),d.moveTo(i+5+c*a*10+a/2,a/2+j+5+e*a*2+(g*a*2/2-b.inSize()*a*2/2)),d.lineTo(i+5+(c+1)*a*10+a/2,a/2+j+5+h*a*2+(g*a*2/2-b.outSize()*a*2/2)),d.stroke();("SigmoidLayer"==b.constructor.name||"SineLayer"==b.constructor.name||"TanhLayer"==b.constructor.name||"ReluLayer"==b.constructor.name)&&(d.fillStyle="white",d.font=a+"px serif",d.fillText(b.constructor.name.slice(0,-5),i+5+(c+.4)*a*10,j+5+b.inSize()/2*a*2+(g*a*2/2-b.inSize()*a*2/2))),b.constructor.name="ConvLayer"}};if(swag.clamp=n,swag.render=r,swag.getLoss=q,swag.tanh=Math.tanh,swag.lin=o,swag.bounce=p,swag.isBrowser=m,swag.gaussRandom=l,window.GPU){let s=new GPU;swag.gpu=s}swag.isBrowser()||("undefined"==typeof module|| void 0===module.exports?window.swag=swag:module.exports=swag)}{class e{constructor(b,c,d,e,f,g=3,h=1,a=0){if(0!=a)throw"Dear user, I have not implemented padding yet.. set it to zero to avoid this message. Star the project if you want me to complete it. or send me 5 bucks ill do it right now.";if(this.lr=.01,this.filters=g,this.inWidth=b,this.inHeight=c,this.inDepth=d,this.filterWidth=e,this.filterHeight=f,this.stride=h,this.padding=a,this.filterw=new Float32Array(g*d*e*f),this.filterws=new Float32Array(g*d*e*f),this.trainIterations=0,this.outData=new Float32Array(Math.ceil((b-e+2*a+1)/h)*Math.ceil((c-f+2*a+1)/h)*this.filters),this.inData=new Float32Array(b*c*d),this.inData.fill(0),this.costs=new Float32Array(b*c*d),this.filterWidth>b+a||this.filterHeight>c+a)throw"Conv layer error: filters cannot be bigger than the input";for(var i=0;i<this.filterw.length;i++)this.filterw[i]=.1*Math.random()*(Math.random()>.5?-1:1);this.hMFHPO=Math.ceil((this.inHeight-this.filterHeight+1)/this.stride),this.wMFWPO=Math.ceil((this.inWidth-this.filterWidth+1)/this.stride),this.hMFWMF=this.hMFHPO*this.wMFWPO,this.wIH=this.inWidth*this.inHeight,this.wIHID=this.inWidth*this.inHeight*this.inDepth,this.fWIH=this.filterWidth*this.filterHeight,this.fWIHID=this.inDepth*this.filterHeight*this.filterWidth}inSize(){return this.inData.length}outSize(){return this.outData.length}inSizeDimensions(){return[this.inWidth,this.inHeight,this.inDepth]}outSizeDimensions(){return[Math.ceil((this.inWidth-this.filterWidth+2*this.padding+1)/this.stride),Math.ceil((this.inHeight-this.filterHeight+2*this.padding+1)/this.stride),this.filters,]}forward(b){if(b){if(b.length!=this.inSize())throw"INPUT SIZE WRONG ON CONV LAYER:\nexpected array size ("+this.inSize()+", dimensions: ["+this.inSizeDimensions()+"]), got: ("+b.length+")";for(var a=0;a<b.length;a++)this.inData[a]=b[a]}this.outData.fill(0);for(var a=0;a<this.filters;a++){let h=a*this.hMFWMF,i=a*this.fWIHID;for(var c=0;c<this.hMFHPO;c++){let j=c*this.stride,k=c*this.wMFWPO;for(var d=0;d<this.wMFWPO;d++){let l=d+k+h,m=d*this.stride;for(var e=0;e<this.inDepth;e++){let n=e*this.wIH+m,o=e*this.fWIH+i;for(var f=0;f<this.filterHeight;f++){let p=(f+j)*this.inWidth+n,q=f*this.filterWidth+o;for(var g=0;g<this.filterWidth;g++)this.outData[l]+=this.inData[g+p]*this.filterw[g+q]}}}}}}backward(g){let j=0;this.trainIterations++;for(var a=0;a<this.inSize();a++)this.costs[a]=0;if(!g&& void 0==this.nextLayer)throw"error backproping on an unconnected layer with no expected parameter input";for(var a=0;a<this.filters;a++){let m=a*this.hMFWMF,n=a*this.fWIHID;for(var c=0;c<this.hMFHPO;c++){let o=c*this.stride,p=c*this.wMFWPO;for(var d=0;d<this.wMFWPO;d++){let h=d+p+m,q=d*this.stride,i=g?g[h]-this.outData[h]:this.nextLayer.costs[h];j+=Math.pow(i,2);for(var e=0;e<this.inDepth;e++){let r=e*this.wIH,s=e*this.fWIH+n;for(var f=0;f<this.filterHeight;f++){let k=(f+o)*this.inWidth+r+q,l=f*this.filterWidth+s;for(var b=0;b<this.filterWidth;b++)this.costs[b+k]+=this.filterw[b+l]*i,this.filterws[b+l]+=this.inData[b+k]*i}}}}}return j/(this.wMFWPO*this.hMFHPO*this.filters)}updateParams(b){for(var a=0;a<this.filterw.length;a++)this.filterw[a]+=this.filterws[a]*this.lr,this.filterws[a]=0;this.trainIterations=0}save(){return JSON.stringify(this,function(a,b){if("filterws"!=a&&"filterbs"!=a&&"inData"!=a&&"outData"!=a&&"costs"!=a&&"gpuEnabled"!=a&&"trainIterations"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b})}static load(d){let a=JSON.parse(d),b=new e(a.inWidth,a.inHeight,a.inDepth,a.filterWidth,a.filterHeight,a.filters,a.stride,a.padding);for(var c=0;c<b.filterw.length;c++)b.filterw[c]=a.filterw[c];return b.lr=a.lr,b}}swag.ConvLayer=e,swag.Conv=e}{class f{constructor(c,a){this.lr=.01,this.gpuEnabled=!1,this.trainIterations=0,this.ws=new Float32Array(c*a),this.bs=new Float32Array(a),this.nextLayer,this.inData=new Float32Array(c),this.outData=new Float32Array(a),this.w=new Float32Array(c*a),this.b=new Float32Array(a),this.costs=new Float32Array(c);for(var b=0;b<c;b++)for(var d=0;d<a;d++)this.w[d+b*a]=1*Math.random()*(Math.random()>.5?-1:1),this.ws[d+b*a]=0;for(var b=0;b<a;b++)this.b[b]=1*Math.random()*(Math.random()>.5?-1:1),this.bs[b]=0}forward(b){if(b){if(b.length!=this.inSize())throw"INPUT SIZE WRONG ON FC LAYER:\nexpected size ("+this.inSize()+"), got: ("+b.length+")";for(var c=0;c<b.length;c++)this.inData[c]=b[c]}for(var a=0;a<this.outSize();a++){this.outData[a]=0;for(var d=0;d<this.inSize();d++)this.outData[a]+=this.inData[d]*this.w[a+d*this.outSize()];this.outData[a]+=this.b[a]}}backward(f){this.trainIterations++;let e=0;for(var a=0;a<this.inSize();a++)this.costs[a]=0;if(f)for(var b=0;b<this.outSize();b++){let c=f[b]-this.outData[b];e+=Math.pow(c,2);for(var a=0;a<this.inSize();a++)this.ws[b+a*this.outSize()]+=this.inData[a]*c*2,this.costs[a]+=this.w[b+a*this.outSize()]*c*2;this.bs[b]+=c}else{if(void 0==this.nextLayer)throw"error backproping on an unconnected layer with no expected parameter input";for(var b=0;b<this.outSize();b++){let d=this.nextLayer.costs[b];e+=Math.pow(d,2);for(var a=0;a<this.inSize();a++)this.ws[b+a*this.outSize()]+=this.inData[a]*d*2,this.costs[a]+=this.w[b+a*this.outSize()]*d*2;this.bs[b]+=d}}for(var a=0;a<this.inSize();a++)this.costs[a]=this.costs[a]/this.outSize();return e/this.outSize()}inSize(){return this.inData.length}outSize(){return this.outData.length}updateParams(c){if(!(this.trainIterations<0)&&"SGD"==c){for(var a=0;a<this.ws.length;a++)this.ws[a]/=this.trainIterations,this.w[a]+=this.ws[a]*this.lr,this.ws[a]=0;for(var b=0;b<this.outSize();b++)this.bs[b]/=this.trainIterations,this.b[b]+=this.bs[b]*this.lr,this.bs[b]=0;this.trainIterations=0}}mutate(b,c){for(var a=0;a<this.w.length;a++)Math.random()<b&&(this.w[a]+=Math.random()*c*(Math.random()>.5?-1:1));for(var a=0;a<this.b.length;a++)Math.random()<b&&(this.b[a]+=Math.random()*c*(Math.random()>.5?-1:1))}save(){this.savedInSize=this.inSize(),this.savedOutSize=this.outSize();let a=JSON.stringify(this,function(a,b){if("ws"!=a&&"bs"!=a&&"inData"!=a&&"outData"!=a&&"costs"!=a&&"gpuEnabled"!=a&&"trainIterations"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b});return delete this.savedInSize,delete this.savedOutSize,a}static load(d){let c=JSON.parse(d),b=new f(c.savedInSize,c.savedOutSize);for(var a=0;a<b.w.length;a++)b.w[a]=c.w[a];for(var a=0;a<b.b.length;a++)b.b[a]=c.b[a];return b.lr=c.lr,b}}swag.FCLayer=f,swag.FC=f}{class a{constructor(a){this.nextLayer,this.inData=new Float64Array(a),this.outData=new Float64Array(a),this.costs=new Float64Array(a)}forward(a){if(a){if(a.length!=this.inSize())throw"INPUT SIZE WRONG ON (Input or output or linear) LAYER:\nexpected size ("+this.inSize()+"), got: ("+a.length+")";for(var b=0;b<a.length;b++)this.inData[b]=a[b]}for(var c=0;c<this.outSize();c++)this.outData[c]=this.inData[c]}backward(c){let d=0;if(c)for(var a=0;a<this.outData.length;a++){let e=c[a]-this.outData[a];this.costs[a]=e,d+=Math.pow(e,2)}else{if(void 0==this.nextLayer)throw"nothing to backpropagate!";c=[];for(var b=0;b<this.outData.length;b++)this.costs[b]=this.nextLayer.costs[b],d+=this.costs[b]}return d/this.inSize()}inSize(){return this.inData.length}outSize(){return this.outData.length}save(){this.savedSize=this.inSize();let a=JSON.stringify(this,function(a,b){if("inData"!=a&&"outData"!=a&&"costs"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b});return delete this.savedInSize,delete this.savedOutSize,a}static load(b){let c=JSON.parse(b);return new a(c.savedSize)}}swag.IdentityLayer=a,swag.Identity=a,swag.Input=a,swag.DummyLayer=a,swag.InputLayer=a,swag.OutputLayer=a,swag.Output=a}{class b{constructor(a){this.nextLayer,this.inData=new Float32Array(a),this.outData=new Float32Array(a),this.costs=new Float32Array(a)}forward(c){if(c)for(var b=0;b<c.length;b++)this.inData[b]=c[b];for(var a=0;a<this.outSize();a++)this.outData[a]=this.inData[a]>0?this.inData[a]:0}backward(b){let d=0;if(!b){if(void 0==this.nextLayer)throw"nothing to backpropagate!";b=[];for(var c=0;c<this.outData.length;c++)b.push(this.nextLayer.costs[c]+this.nextLayer.inData[c])}for(var a=0;a<this.outSize();a++){let e=b[a]-this.outData[a];d+=Math.pow(e,2),this.outData[a]>=0&&(this.costs[a]=e)}return d/this.outSize()}inSize(){return this.inData.length}outSize(){return this.outData.length}save(){this.savedSize=this.inSize();let a=JSON.stringify(this,function(a,b){if("inData"!=a&&"outData"!=a&&"costs"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b});return delete this.savedInSize,delete this.savedOutSize,a}static load(a){let c=JSON.parse(a);return new b(c.savedSize)}}swag.LeakyReluLayer=b,swag.LeakyRelu=b,swag.LRelu=b}{class g{constructor(a,b,c,e,f,d=1,g=0){if(0!=g)throw"Dear user, I have not implemented padding yet.. set it to zero to avoid this message. Star the project if you want me to complete it. or send me 5 bucks ill do it right now.";if(this.inWidth=a,this.inHeight=b,this.inDepth=c,this.filterWidth=e,this.filterHeight=f,this.stride=d,this.padding=0,this.outData=new Float32Array(Math.ceil((a-e+1)/d)*Math.ceil((b-f+1)/d)*this.inDepth),this.inData=new Float32Array(a*b*c),this.costs=new Float32Array(a*b*c),this.maxIndexes=new Float32Array(this.outData.length),this.accessed=new Float32Array(this.costs.length).fill(1),this.filterWidth>a||this.filterHeight>b)throw"Max Pool layer error: Pooling size (width / height) cannot be bigger than the inputs corresponding (width/height)";this.hMFHPO=Math.ceil((this.inHeight-this.filterHeight+1)/this.stride),this.wMFWPO=Math.ceil((this.inWidth-this.filterWidth+1)/this.stride),this.hMFWMF=this.hMFHPO*this.wMFWPO,this.wIH=this.inWidth*this.inHeight}inSize(){return this.inData.length}outSize(){return this.outData.length}inSizeDimensions(){return[this.inWidth,this.inHeight,this.inDepth]}outSizeDimensions(){return[Math.ceil((this.inWidth-this.filterWidth+1)/this.stride),Math.ceil((this.inHeight-this.filterHeight+1)/this.stride),this.inDepth]}forward(a){if(a){if(a.length!=this.inSize())throw"INPUT SIZE WRONG ON MAX POOL LAYER:\nexpected array size ("+this.inSize()+", dimensions: ["+this.inSizeDimensions()+"]), got: ("+a.length+")";for(var c=0;c<a.length;c++)this.inData[c]=a[c]}this.outData.fill(0);for(var d=0;d<this.hMFHPO;d++){let j=d*this.stride,m=d*this.wMFWPO;for(var e=0;e<this.wMFWPO;e++){let n=e*this.stride;for(var f=0;f<this.inDepth;f++){let k=e+m+f*this.hMFWMF,l=f*this.wIH+n,g=this.inData[j*this.inWidth+l];for(var h=0;h<this.filterHeight;h++){let i=(h+j)*this.inWidth+l;for(var b=1;b<this.filterWidth;b++)this.inData[b+i]>g&&(g=this.inData[b+i],this.maxIndexes[k]=b+i)}this.outData[k]=g}}}}backward(b){this.costs.fill(0);let f=0;if(!b&& void 0==this.nextLayer)throw"error backproping on an unconnected layer with no expected parameter input";for(var c=0;c<this.hMFHPO;c++){this.stride;let h=c*this.wMFWPO;for(var d=0;d<this.wMFWPO;d++){this.stride;for(var e=0;e<this.inDepth;e++){let a=d+h+e*this.hMFWMF,g=b?b[a]-this.outData[a]:this.nextLayer.costs[a];f+=Math.pow(g,2),this.costs[this.maxIndexes[a]]+=g,this.accessed[this.maxIndexes[a]]++}}}return f/(this.hMFHPO*this.wMFWPO*this.inDepth)}save(){return JSON.stringify(this,function(a,b){if("inData"!=a&&"outData"!=a&&"costs"!=a&&"gpuEnabled"!=a&&"trainIterations"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b})}static load(b){let a=JSON.parse(b);return new g(a.inWidth,a.inHeight,a.inDepth,a.filterWidth,a.filterHeight,a.stride,a.padding)}}swag.MaxPoolLayer=g,swag.MaxPool=g}{class h{static leakySlope=.25;constructor(a){this.nextLayer,this.inData=new Float32Array(a),this.outData=new Float32Array(a),this.costs=new Float32Array(a)}forward(c){if(c)for(var b=0;b<c.length;b++)this.inData[b]=c[b];for(var a=0;a<this.outSize();a++)this.outData[a]=this.inData[a]>0?this.inData[a]:0}backward(b){let e=0;if(!b){if(void 0==this.nextLayer)throw"nothing to backpropagate!";b=[];for(var c=0;c<this.outData.length;c++)b.push(this.nextLayer.costs[c]+this.nextLayer.inData[c])}for(var a=0;a<this.outSize();a++){let d=b[a]-this.outData[a];e+=Math.pow(d,2),this.outData[a]>=0?this.costs[a]=d:this.costs[a]=d*swag.LeakyReluLayer.leakySlope}return e/this.outSize()}inSize(){return this.inData.length}outSize(){return this.outData.length}save(){this.savedSize=this.inSize();let a=JSON.stringify(this,function(a,b){if("inData"!=a&&"outData"!=a&&"costs"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b});return delete this.savedInSize,delete this.savedOutSize,a}static load(a){let b=JSON.parse(a);return new h(b.savedSize)}}swag.ReluLayer=h,swag.Relu=h}{class c{sigmoid(a){return 1/(1+Math.exp(-a))}sigmoidPrime(a){return Math.exp(-a)/Math.pow(1+Math.exp(-a),2)}constructor(a){this.nextLayer,this.inData=new Float32Array(a),this.outData=new Float32Array(a),this.costs=new Float32Array(a)}forward(a){if(a){if(a.length!=this.inData.length)throw"INPUT SIZE WRONG ON SIG LAYER:\nexpected size ("+this.inSize+"), got: ("+a.length+")";for(var b=0;b<a.length;b++)this.inData[b]=a[b]}for(var c=0;c<this.outSize();c++)this.outData[c]=this.sigmoid(this.inData[c])}backward(b){let d=0;if(!b){if(void 0==this.nextLayer)throw"nothing to backpropagate!";b=[];for(var c=0;c<this.outData.length;c++)b.push(this.nextLayer.costs[c]+this.nextLayer.inData[c])}for(var a=0;a<this.outSize();a++){let e=b[a]-this.outData[a];d+=Math.pow(e,2),this.costs[a]=e*this.sigmoidPrime(this.inData[a])}return d/this.outSize()}inSize(){return this.inData.length}outSize(){return this.outData.length}save(){this.savedSize=this.inSize();let a=JSON.stringify(this,function(a,b){if("inData"!=a&&"outData"!=a&&"costs"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b});return delete this.savedInSize,delete this.savedOutSize,a}static load(a){let b=JSON.parse(a);return new c(b.savedSize)}}swag.SigmoidLayer=c,swag.Sigmoid=c,swag.Sig=c}{class d{sine(a){return Math.sin(a)}sinePrime(a){return Math.cos(a)}constructor(a){this.nextLayer,this.inData=new Float32Array(a),this.outData=new Float32Array(a),this.costs=new Float32Array(a)}forward(a){if(a){if(a.length!=this.inData.length)throw"INPUT SIZE WRONG ON Sine LAYER:\nexpected size ("+this.inSize+"), got: ("+a.length+")";for(var b=0;b<a.length;b++)this.inData[b]=a[b]}for(var c=0;c<this.outSize();c++)this.outData[c]=this.sine(this.inData[c])}backward(b){if(!b){if(void 0==this.nextLayer)throw"nothing to backpropagate!";b=[];for(var c=0;c<this.outData.length;c++)b.push(this.nextLayer.costs[c]+this.nextLayer.inData[c])}for(var a=0;a<this.outSize();a++){let d=b[a]-this.outData[a];this.costs[a]=d*this.sinePrime(this.inData[a])}}inSize(){return this.inData.length}outSize(){return this.outData.length}save(){this.savedSize=this.inSize();let a=JSON.stringify(this,function(a,b){if("inData"!=a&&"outData"!=a&&"costs"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b});return delete this.savedInSize,delete this.savedOutSize,a}static load(a){let b=JSON.parse(a);return new d(b.savedSize)}}swag.SineLayer=d,swag.Sine=d,swag.Sin=d}{class i{tanh(a){return Math.tanh(a)}tanhPrime(a){return 1-Math.pow(Math.tanh(a),2)}constructor(a){this.nextLayer,this.inData=new Float32Array(a),this.outData=new Float32Array(a),this.costs=new Float32Array(a)}forward(a){if(a){if(a.length!=this.inData.length)throw"INPUT SIZE WRONG ON Tanh LAYER:\nexpected size ("+this.inSize+"), got: ("+a.length+")";for(var b=0;b<a.length;b++)this.inData[b]=a[b]}for(var c=0;c<this.outSize();c++)this.outData[c]=this.tanh(this.inData[c])}backward(b){let d=0;if(!b){if(void 0==this.nextLayer)throw"nothing to backpropagate!";b=[];for(var c=0;c<this.outData.length;c++)b.push(this.nextLayer.costs[c]+this.nextLayer.inData[c])}for(var a=0;a<this.outSize();a++){let e=b[a]-this.outData[a];this.costs[a]=e*(1-Math.pow(this.outData[a],2)),d+=Math.pow(e,2)}return d/this.outSize()}inSize(){return this.inData.length}outSize(){return this.outData.length}save(){this.savedSize=this.inSize();let a=JSON.stringify(this,function(a,b){if("inData"!=a&&"outData"!=a&&"costs"!=a&&"nextLayer"!=a&&"previousLayer"!=a)return b});return delete this.savedInSize,delete this.savedOutSize,a}static load(a){let b=JSON.parse(a);return new i(b.savedSize)}}swag.TanhLayer=i,swag.Tanh=i}